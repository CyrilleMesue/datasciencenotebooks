% Define the filter size we will use in step 2:
filtsize = 85;

% Creating test image 'im' by splicing together two built in images.
% Also zero-padding (adding zeros around the border) with half the 
% filter size (filtsize) we will use so that the filter could be 
% centered on any actual image pixel, including those near the border.
% 'coins.png' contains bright nickels and dimes on a dark background
% 'eight.tif' contains dark quarters on a bright background, so we invert it
% to match 'coins.png'
im1 = imread('coins.png');
[r,c] = size(im1);
im2 = imread('eight.tif');
[r2,c2] = size(im2);
filtsizeh = floor(filtsize/2);
im = zeros(r+r2+filtsize,c+filtsize);
im(filtsizeh+1:filtsizeh+r+r2,filtsizeh+1:filtsizeh+c) = [im1;255-im2(:,1:c)];
[r,c] = size(im);
imagesc(im);colormap(gray);title('test image');axis equal;

% Initializing assessed/displayed variables as empty so that code is executable 
msk=[]; msk_dil=[]; msk_dil_erd=[]; centroid=[]; component_size=[]; 

%%%%% 1. Localize the centroid of each coin
% Otsu threshold
[mask,threshold] = OtsuThreshold(im);
msk = mask;
figure; imagesc(msk); colormap(gray); title('Otsu'); axis equal;

% Dilate 
msk_dil = imdilate(msk,ones(7,7));

figure; imagesc(msk_dil); colormap(gray); title('Dilated'); axis equal;

% Erode 
msk_dil_erd = imerode(msk_dil,ones(17,17));

figure; imagesc(msk_dil_erd); colormap(gray); title('Eroded'); axis equal;

% Connected components to get centroids of coins:

region = regionprops('table', msk_dil_erd, 'Centroid', 'Area');
centroid = region.Centroid;
centroid = round(centroid);
component_size = region.Area;
centroid
component_size


%%%%%%%%%%%%%%%%%%%% Helper Functions %%%%%%%%%%%%%%%%%%%%%
function [mask,thrsh] = OtsuThreshold(img)
    % Define the Otsu threshold 'thrsh' using the histogram of img
    hist = imhist(img);
    thrsh =  otsuthresh(hist)*255;
    % Apply the threshold to 'img' to make 'msk'
    mask = img >  thrsh;
end




function [filter,xc,yc] = MakeCircleMatchingFilter(diameter,W)
    % initialize filter
    filter = zeros(W);
    % define coordinates for the center of the WxW filter
    xc = (W + 1)/2;
    yc = (W + 1)/2;
    % Use double-for loops to check if each pixel lies in the foreground of the circle
    for i = 1:W
        for j = 1:W
            if ((i - xc)^2 + (j - yc)^2) <= ((diameter)/2)^2
                filter(i,j) = 1;
            end
        end
    end

end


function [coinvalue,x_plot,y_plot,col] = AddCoinToPlotAndCount(x,y,cls)
    % initialize radians for defining x_plot and y_plot using cos and sin functions
    rads = 0:2*pi/32:2*pi;
    % initialize parameters for radius and color of circle for each type of coin
    radius = 0;
    coinvalue = 0;
    col = 'k';
    % use if-elseif statement to define x_plot, y_plot, col
    %   when cls is 1, we found a dime
    if cls == 1
        radius = 22;
        col = 'r';
        coinvalue = 10;
    %   when cls is 2, we found a nickel
    elseif cls == 2
        radius = 30;
        col = 'g';
        coinvalue = 5;
    
    %   when cls is 3, we found a quarter
    else
        radius = 40;
        col = 'm';
        coinvalue = 25;
    end
    
    x_plot = radius*cos(rads) + x;
    y_plot = radius*sin(rads) + y;
    plot(x_plot,y_plot,col);
end

